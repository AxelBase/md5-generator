import{f as v,a as d}from"../chunks/DfEQACpH.js";import"../chunks/d3u-483z.js";import{a1 as m,a5 as e,a0 as B,a6 as _,a7 as w,a8 as h,a3 as s,a4 as l}from"../chunks/BtxUc5Ff.js";import{h as M}from"../chunks/C-TpbU2e.js";import{s as a}from"../chunks/CILCvtuc.js";import{b as t}from"../chunks/D65YHoCb.js";const F=!0,H=Object.freeze(Object.defineProperty({__proto__:null,prerender:F},Symbol.toStringTag,{value:"Module"}));var k=v('<meta name="description" content="Learn how AxelBase uses incremental hashing to process 100+ MB files smoothly in the browser without freezing or memory crashes."/> <meta property="og:title" content="Handling Large Files Without Freezing | AxelBase"/> <meta property="og:description" content="No more browser tabs locking up. See how chunked, incremental MD5 hashing works under the hood."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),z=v(`<div class="container fade-in post-layout svelte-1li990r"><div class="breadcrumbs svelte-1li990r"><a class="svelte-1li990r">Blog</a> <span>/</span> <p class="svelte-1li990r">Handling Large Files Without Freezing</p></div> <article class="prose svelte-1li990r"><h1 class="svelte-1li990r">Handling Large Files (>10 MB) Without Freezing</h1> <p class="post-meta svelte-1li990r">Published: November 23, 2025</p> <p class="lead svelte-1li990r">Drop a 500 MB file into most online hash tools → tab freezes. Drop it here → hash appears in seconds.</p> <h2 class="svelte-1li990r">The Problem with Naive Implementations</h2> <p class="svelte-1li990r">Many web tools do this:</p> <ul class="svelte-1li990r"><li class="svelte-1li990r">Read entire file into memory with <code>FileReader.readAsArrayBuffer()</code></li> <li class="svelte-1li990r">Try to process 1 GB+ at once</li> <li class="svelte-1li990r">Browser main thread blocks → tab becomes unresponsive</li></ul> <h2 class="svelte-1li990r">Our Solution: Incremental + Chunked Hashing</h2> <p class="svelte-1li990r">We process files in 2 MB chunks:</p> <ol><li><code>file.slice(offset, offset + 2×1024×1024)</code></li> <li><code>await slice.arrayBuffer()</code></li> <li><code>spark.append(buffer)</code> → updates internal MD5 state</li> <li>Repeat until end of file</li></ol> <p class="svelte-1li990r">Result: memory usage stays under 10 MB even for multi-gigabyte files. The UI remains fully responsive.</p> <h2 class="svelte-1li990r">Real Performance Numbers</h2> <ul class="svelte-1li990r"><li class="svelte-1li990r">100 MB file → ~2.1 seconds</li> <li class="svelte-1li990r">1 GB file → ~18 seconds (still responsive)</li> <li class="svelte-1li990r">Tested on mid-range laptops and Android phones</li></ul> <h2 class="svelte-1li990r">Why This Matters</h2> <p class="svelte-1li990r">Developers regularly verify ISOs, VM images, game patches, and database dumps — all routinely over 1 GB.  
			You shouldn’t need a desktop tool for that in 2025.</p> <hr class="my-5"/> <p class="text-center svelte-1li990r"><a class="btn btn-primary">Try with a Big File</a> <a class="btn btn-outline-secondary ms-3">All Posts</a></p></article></div>`);function L(u){var r=z();M("1li990r",b=>{var p=k(),y=e(B(p),6);h(4),m(()=>a(y,"content",`${t??""}/blog/posts/post5`)),_(()=>{w.title="Handling Large Files (>10 MB) Without Freezing | AxelBase"}),d(b,p)});var i=s(r),f=s(i);h(4),l(i);var o=e(i,2),n=e(s(o),30),c=s(n),g=e(c,2);l(n),l(o),l(r),m(()=>{a(f,"href",`${t??""}/blog`),a(c,"href",`${t??""}/`),a(g,"href",`${t??""}/blog`)}),d(u,r)}export{L as component,H as universal};
